<template>
    <form class="form-post" action="">
        <div class="form-post__container">
            <div>
                <button type="button" class="form-post__brownse-btn form-post-btn" v-if="canBrownse" @click.stop="showBrownser">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path
                            fill="currentColor"
                            d="M12 2.00098C6.486 2.00098 2 6.48698 2 12.001C2 17.515 6.486 22.001 12 22.001C17.514 22.001 22 17.515 22 12.001C22 6.48698 17.514 2.00098 12 2.00098ZM17 13.001H13V17.001H11V13.001H7V11.001H11V7.00098H13V11.001H17V13.001Z"
                        ></path>
                    </svg>
                </button>
            
                <Brownser ref="brownser" />            
            </div>


            <!--
                @keydown.enter.prevent="submit($event); updateHeight($event.target)"
                @input="updateHeight($event.target); $emit('update:modelValue', $event.target.value)" 
                :class="{ 'form-post__field--active' : value }"

                <span>[Premiere span]</span><span contenteditable="false"><img style="width:24px" :src="require('@/assets/twemoji/svg/1f170.svg')"></span><span>[Deuxieme span]</span>           
            
                        @keypress="parse"
                @input="parse($event); parseEmoji($event)"
            -->

            <div

                @drop.prevent="drop" @dragenter.prevent="" @dragstart.prevent="" @drag.prevent=""
                @keypress.enter.prevent="submit"
                @keydown.esc="escape"
                @input="parseEmpty(); parseEmoji(); parseURL(); textarea.normalize(); $emit('updateInput', getDataText())"
                @paste.prevent="paste"

                class="form-post__field"
                contenteditable="true"
                :title="placeholder"
                ref="textarea"
                spellcheck="false"
                v-html="value"

            ></div>

            <button type="button" class="form-post-btn form-post-btn__gif-btn" v-if="canGIF" >
                <svg width="24" height="24" viewBox="0 0 24 24">
                    <path
                        fill="currentColor"
                        d="M2 2C0.895431 2 0 2.89543 0 4V20C0 21.1046 0.89543 22 2 22H22C23.1046 22 24 21.1046 24 20V4C24 2.89543 23.1046 2 22 2H2ZM9.76445 11.448V15.48C8.90045 16.044 7.88045 16.356 6.74045 16.356C4.11245 16.356 2.66045 14.628 2.66045 12.072C2.66045 9.504 4.23245 7.764 6.78845 7.764C7.80845 7.764 8.66045 8.004 9.32045 8.376L9.04445 10.164C8.42045 9.768 7.68845 9.456 6.83645 9.456C5.40845 9.456 4.71245 10.512 4.71245 12.06C4.71245 13.62 5.43245 14.712 6.86045 14.712C7.31645 14.712 7.64045 14.616 7.97645 14.448V12.972H6.42845V11.448H9.76445ZM11.5481 7.92H13.6001V16.2H11.5481V7.92ZM20.4724 7.92V9.636H17.5564V11.328H19.8604V13.044H17.5564V16.2H15.5164V7.92H20.4724Z"
                    ></path>
                </svg>
            </button>
            <button type="button" class="form-post-btn" v-if="canEmoji" @click="showEmojiDisplay">
                <svg width="24" height="24" viewBox="0 0 24 24">
                    <path
                        fill="currentColor"
                        d="M12 2.00098C6.486 2.00098 2 6.48698 2 12.001C2 17.515 6.486 22.001 12 22.001C17.514 22.001 22 17.515 22 12.001C22 6.48698 17.514 2.00098 12 2.00098ZM17 13.001H13V17.001H11V13.001H7V11.001H11V7.00098H13V11.001H17V13.001Z"
                    ></path>
                </svg>
            </button>            
        </div>

        
        <div class="respond-info" v-if="idPostToReply && canRespond">
            <span>Répondre à <span class="respond-info__user">{{ getNameToReply }}</span> &#8226; Post #{{ idPostToReply }}</span>
            
            
            <button type="button" class="respond-info__close" @click="SET_ID_POST_TO_REPLY(null)" >
                <svg aria-hidden="false" width="16" height="16" viewBox="0 0 14 14">
                    <path fill="currentColor" d="M7.02799 0.333252C3.346 0.333252 0.361328 3.31792 0.361328 6.99992C0.361328 10.6819 3.346 13.6666 7.02799 13.6666C10.71 13.6666 13.6947 10.6819 13.6947 6.99992C13.6947 3.31792 10.7093 0.333252 7.02799 0.333252ZM10.166 9.19525L9.22333 10.1379L7.02799 7.94325L4.83266 10.1379L3.89 9.19525L6.08466 6.99992L3.88933 4.80459L4.832 3.86259L7.02733 6.05792L9.22266 3.86259L10.1653 4.80459L7.97066 6.99992L10.166 9.19525Z"></path>
                </svg>
            </button>
        </div>

    </form>

</template>

<script>
import Brownser from "@/components/Brownser.vue";
import {   mapMutations, mapState } from "vuex";
export default {
    data() {
        return {
            selection: 0,
            textarea: "",
        };
    },
    components : {
        Brownser
    },
    props: {
        value: { type: String, default : '' },
        canBrownse : { type: Boolean, default : false },
        canGIF : { type: Boolean, default : false },
        canEmoji : { type: Boolean, default : false },
        placeholder : { type : String, default : "Envoyer un message dans ce groupe" },
        canRespond : {type : Boolean, default : false }
    },
    watch : {
        idPostToReply(){
            if(this.canRespond && this.idPostToReply) this.textarea.focus();
        }
    },
    computed: {
        ...mapState('emojiModule',['emojisShortCodeIndex', 'display']),
        ...mapState('postModule',['idPostToReply', 'listPost']),
        isEmpty(){
            console.log(this.textarea.innerHTML == '')
            return this.textarea.innerHTML == '';
        },
        getNameToReply(){
            //Vu que ca sera restreint à répondre auniquement au post (et non au post recursif)
            //je peux aller piocher dans l'array listPost sans me soucier
            return this.listPost.find(e => e.id == this.idPostToReply).user_username
        }
    },
    methods: {
        ...mapMutations('emojiModule', ['SET_POSITION', 'SET_VISIBILITY']),
        ...mapMutations('postModule', ['SET_ID_POST_TO_REPLY']),
        showEmojiDisplay(e){
            const bound = e.target.getBoundingClientRect();
            this.SET_POSITION({
                x : bound.right - this.display.width,
                y : bound.top - this.display.height*-1,                
            })
            this.SET_VISIBILITY(true)
        },
        escape(){
            this.$emit('escape')
        },
        showBrownser(){
            this.$refs['brownser'].show();
        },
        submit(e) {
            const value = this.getDataText().trim();
            if (value == "") return;
            this.$emit("submit", value)
            e.target.innerHTML = "";
            
        },
        paste(event) {
            let paste = (event.clipboardData || window.clipboardData).getData("text");
            const selection = window.getSelection();
            if (!selection.rangeCount) return false;
            selection.deleteFromDocument();
            selection.getRangeAt(0).insertNode(document.createTextNode(paste));
            this.parseEmoji();
        },
        drop(event) {
            let drop = event.dataTransfer.getData("text");

            const selection = window.getSelection();
            if (!selection.rangeCount) return false;
            selection.deleteFromDocument();

            selection.getRangeAt(0).insertNode(document.createTextNode(drop));
            //this.parseEmoji();
        },
        parseURL(){
            const reg = /https?:\/\/[www.]?[\w]+\.[\w()]+[-a-zA-Z0-9()@:%_+.~#?&/=]+/g;

            const listNodes = [];

            this.textarea.childNodes.forEach(node => {
                const textContent = node.textContent;
                if(reg.test(textContent)){
                    const listTextNode = textContent.split(reg).map(text => document.createTextNode(text));
                    const listSpan = textContent.match(reg).map(match => this.createSpanBlue(match));
                    const listNodeToAppend = listTextNode.reduce((a,v,i)=> [...a,v,listSpan[i] ],[]).slice(0,-1);
                    listNodes.push({ reference : node, after : listNodeToAppend })
                }
                else if(node.nodeType == 1 && node.textContent != ''){ //si le noeud est un span blue le remplacer par un textNode
                    listNodes.push({ reference : node, after : [document.createTextNode(textContent)] })
                }
            })

            //Add
            listNodes.forEach(node => {
                node.after.forEach(n => {  this.textarea.insertBefore(n , node.reference) });
                this.textarea.removeChild(node.reference)
            })


        },
        add(listNodes){
            listNodes.forEach(node => {
                node.after.forEach(n => {  this.$refs['textarea'].insertBefore(n , node.reference) });
                this.$refs['textarea'].removeChild(node.reference)
            })
        },
        parseEmoji() {
            const reg = /:\w+:/g;
            const listNodes = [];


            if(/:\w+:/.test(this.textarea.textContent)){
                
                this.textarea.childNodes.forEach(node => {
                    const textContent = node.textContent;
                    if(/:\w+:/.test(textContent)){
                        const listTextNode = textContent.split(reg).map(text => document.createTextNode(text));
                        const listShortCodeNode = textContent.match(reg).map(shortCode => {
                            return (this.emojisShortCodeIndex[shortCode])
                            ? this.createSpanImgNode(shortCode)
                            : document.createTextNode(shortCode);
                        });

                        const listNodeToAppend = listTextNode.reduce((a,v,i)=> [...a,v,listShortCodeNode[i] ],[]).slice(0,-1);

                        listNodes.push({ reference : node, after : listNodeToAppend });
                    }
                })
                
                this.add(listNodes);
                      

                /*listNodes.forEach(node => {
                    if(node.reference == window.getSelection().anchorNode){
                        const lengthBefore = node.reference.textContent.length;
                        const lengthAfter = node.after.reduce((a,node) =>  a += node.textContent.length || 1 ,0);
                        let index = 0;
                        node.after.forEach(nodeAfter => {
                            index += nodeAfter.textContent.length || 1;
                            if(window.getSelection().focusOffset <= index)
                        })
                    }
                })*/
                
            }
            
        },
        /*parseEmoji() {
            const reg = /:\w+:/g;
            if(reg.test(this.textarea.textContent)){
                let index, listNodeToAppend;

                this.textarea.textContent.match(reg).forEach(shortCode => {
                    if(Object.keys(this.emojisShortCodeIndex).includes(shortCode)){
                        index = 0;
                        for (index in [...this.textarea.childNodes]) if(reg.test(this.textarea.childNodes[index].textContent)) break;
                        const childNode =  this.textarea.childNodes[index];
                        const listTextNode = childNode.textContent.split(shortCode).map(text => document.createTextNode(text != '' ? text : '\u{FEFF}'));
                        
                        this.textarea.removeChild(childNode); //Delete
                        
                        const childNodeRef = this.textarea.childNodes[index];
                        listNodeToAppend = listTextNode.reduce((a,v)=>[...a,v,this.createSpanImgNode(shortCode)],[]).slice(0,-1)
                        listNodeToAppend.forEach(node => { //Append
                            this.textarea.insertBefore(node ,childNodeRef)
                        })


                        let el_cursor = this.textarea.childNodes[parseInt(index)+listNodeToAppend.length-1];
                        window.getSelection().collapse(el_cursor, 0); 
                        this.textarea.normalize(); 
                    }
                })
            }
            
        },*/
        getDataText() {
            let el = this.$refs["textarea"];
            let str = "";
            el.childNodes.forEach((node) => {
                if (node.nodeType == 1) {
                    // 1 => Span
                    str += node.querySelector("img") ? node.querySelector("img").alt : node.textContent;
                } else str += node.textContent || "";
            });
            //console.log(str == '')
            return str;
        },
        parseEmpty() {
            if (this.getDataText().replaceAll("\u{FEFF}", "") == "") this.textarea.innerHTML = "";
        },
        createSpanImgNode(shortCode){
            const span =  document.createElement('span');
                    span.setAttribute('contenteditable','false');
                    span.innerHTML = 
                    `<img width="15px" alt="${shortCode}" src="${require("@/assets/twemoji/svg/" +
                        this.emojisShortCodeIndex[shortCode].u.join("-").toLowerCase() +
                    ".svg")}">`;
            return span
        },
        createSpanBlue(text){
            const span =  document.createElement('span');
                    span.setAttribute('style','color : blue');
                    span.innerHTML = text;
            return span
        },
        createZeroText() {
            return document.createTextNode("\u{FEFF}");
        }
    },
    mounted() {
        this.textarea = this.$refs["textarea"];
    },
};
</script>

<style lang="scss">
.form-post {
    border-radius: 4px;
    background-color: $grey-47;
    &__container{
        
        color: $grey-142;

        display: flex;
        align-items: flex-start;
        padding: 10px;
        position: sticky;
        top: 0;
        z-index: 2;
        
        @include setMediaScreen(mobile){
            flex-wrap: wrap;
        }
    }


    &__field {
        flex: 1;
        color: inherit;
        background-color: transparent;
        border: none;
        overflow: hidden;
        padding: 7px;
        word-break: break-all;
        @include setCircularStdFont("Book");

        @include setMediaScreen(mobile){
            order : 1;
            min-width : 100%;
        }

        &:not(:empty) {
            color: lighten($grey-142, 30%);
        }
    }


    &__brownse-btn {
    }
}

.form-post-btn {
    padding: 4px;
    margin: 0 4px;
    &:hover {
        color: lighten($grey-142, 10%);
    }

    &__gif-btn{
        margin-left : auto;
    }
}

.respond-info {
    display : flex;
    align-items : center;
    height : 35px;
    background-color : $grey-21;
    width: 100%;
    border-radius: 0 0 4px 4px;
    font-size : 13px;
    color : $grey-166;
    
    padding : 0px 15px;

    &__close{
        padding : 5px;
        margin-left : auto;
    }

    &__user{
        color : $success;
    }

}
</style>
